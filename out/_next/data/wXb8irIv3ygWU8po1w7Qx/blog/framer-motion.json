{"pageProps":{"frontMatter":{"title":"🚀 Framer-motion","author":"Dongha Kang","date":"2022-01-18","tag":["React","UI/UX"]},"slug":"framer-motion","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      h2: \"h2\",\n      pre: \"pre\",\n      code: \"code\",\n      ol: \"ol\",\n      li: \"li\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"여러가지의 애니메이션 비법을 알아가는 도중에 그나마 제일 편리하고, 그나마 제일 많은 일을 할 수 있는 것을 알아보고 있다. 그 중하나가 framer-motion 인것 같다. (현재, gsap, react-reveal, react-spring, wowjs, 등을 써봤다)\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"🚀 Installation\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"yarn add framer-motion\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"😀 기-본-\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"...\\nimport { motion } from 'framer-motion';\\n\\nconst Page = () => {\\n  return (\\n  <motion.div\\n    animate={{x: 100}}\\n  >\\n    Hello, Framer Motion\\n  </motion.div>\\n  )\\n}\\n\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"위의 코드는 Hello, Framer Motion이 있는 div를 첫 시작 위치에서 x: 100 인 곳에 자연스럽게 animation을 이용해준다. 아무 설정이 없다면 x: 0에서 x: 100으로 자연스럽게 이동 한다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"😁 초깃값\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"<motion.div\\n  animate={{x: 100}}\\n  initial={{x: -100}}\\n>\\n  Hello, Framer Motion\\n</motion.di>\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"초기 위치를 설정해줄수도 있다. 저렇게 작성할 경우 initial 값이 -100 이기 때문에 x: -100 에서 x: 100으로 자연스럽게 이동한다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"😅 Transition\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"<motion.div\\n  animate={{ x: 100 }}\\n  initial={{ x: -100 }}\\n  transition={{ delay: 1.5, duration: 1.5, type: \\\"spring\\\" }}\\n>\\n  Hello, Framer Motion\\n</motion.div>\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"transition은 애니메이션의 설정값을 바꿔준다. 위 코드 같은 경우 1.5초뒤 1.5초 동안 스프링 애니메이션이 진행이된다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"✨ Tip: \", _jsx(_components.code, {\n          children: \"x: [0, -20, -40, -50]\"\n        }), \" 이런식으로 배열로 생성하면, keyframe이 생성이 되는데\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"😅 Hover\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"<motion.div whileHover={{ scale: 1.1 }}>Hello, Framer Motion</motion.div>\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"만약 div에 마우스를 가져다 대면 animation이 실행된다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"😋 Variants\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"initial, animate, transition이 많아지면 많아질수록 코드가 길어지고 더러워 질수도 있다. 그래서 Variant를 사용한다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const containerVariants = {\\n  hidden : {\\n  opacity: 0,\\n  x: '100vw'\\n  },\\n  visible: {\\n  opacity: 1,\\n  x: 0\\n  }\\n}\\n...\\n\\nconst Page = () => {\\n  return (\\n  <motion.div\\n    variants={containerVariants}\\n    initial=\\\"hidden\\\"\\n    animate=\\\"visible\\\"   // transition은 visible에 임베드 되어있어서 선언 안해도 됨\\n  >\\n    Hello, Framer Motion\\n  </motion.div>\\n  )\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 식으로 variant만 빼놓은 파일을 import해서 모든 애니메이션들이 같은 애니메이션을 사용할 수 있게끔 코드를 클린할수 있다!\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"더 나아가 parent motion의 variant 변수의 이름이 같다면 아무리 variant 종류가 다르더라도 이름을 선언 안해도 된다. 무슨 말이냐면...\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const parentVariant = {\\n  hidden : {\\n  opacity: 0,\\n  x: '100vw'\\n  },\\n  visible: {\\n  opacity: 1,\\n  x: 0\\n  }\\n}\\n\\nconst childVariant = {\\n  hidden : {\\n  opacity: 1,\\n  x: 0\\n  },\\n  visible: {\\n  opacity: 0,\\n  x: '100vw'\\n  }\\n}\\n...\\n\\nconst Page = () => {\\n  return (\\n  <motion.div\\n    variants={parentVariant}\\n    initial=\\\"hidden\\\"\\n    animate=\\\"visible\\\"\\n  >\\n    Hello, Framer Motion\\n    <motion.div\\n    variants={childVariant} // # code clean\\n    >\\n    Children\\n    </motion.div>\\n  </motion.div>\\n  )\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"위에 코드 처럼, variant들 안에 hidden 과 visible값이 곂치기 때문에 아무리 그 안에 있는 animation 속성들의 값이 달라도 child는 자동으로 그의 알맞는 variant의 initial 과 animate을 자동으로 연결 시켜준다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"즉, \", _jsx(_components.code, {\n          children: \"initial=’hidden’ animate=’visible’\"\n        }), \" 을 생략해도 같은 값이 나온다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"🥸 Yoyo\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const containerVariants = {\\n  hover : {\\n  opacity: 0,\\n  x: '100vw'\\n  transition: {\\n    yoyo: 10     // Infinity\\n  }\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"정해진 수만큼 (Infinity 같은 경우 무제한으로) variants를 반복한다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"🤣 AnimatePresence\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Route이 바뀌거나 Component의 현황이 바뀔때 유용하다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"변경시 component중 일부가 삭제되거나 추가 될 때,\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"React router dom을 이용해서 페이지에서 페이지로 이동될때\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"본인은 2번을 더 많이 사용할것 같으니, 2번을 제대로 알아보자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// App.js\\n...\\n<AnimatePresence>\\n  <Routes>\\n  <Route path='/' element={<Home/>}/>\\n  /* ... */\\n  </Routes>\\n</AnimatePresence>\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"AnimatePresence를 묶어 줌으로서 Animation이 진행되고 여기서 transition이 해당되는것을 알려준다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// App.js\\nconst App = () => {\\n  const location = useLocation()\\n\\n  ...\\n  return (\\n  <AnimatePresence exitBeforeEnter>\\n    <Routes location={location} key={location.key}>\\n    <Route path='/' element={<Home/>}/>\\n    /* ... */\\n    </Routes>\\n  </AnimatePresence>\\n  )\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"location={location}, key={location.key}\"\n        }), \" 을 넘겨 줌으로서 현 페이지의 위치를 미리 미리 알수 있고 나중에 이 location값이 변경되면 (화면이 옮겨지면), exit과 transition을 이용하여 애니메이션을 진행할 수 있다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이제 variants 를 한번 추가해보자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const containerVariant = {\\n...\\n  exit: {\\n  x: '-100vw',\\n  transition: { ease: 'easeInOut' }\\n  }\\n}\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}