{"pageProps":{"frontMatter":{"title":"RWD🪗 그냥 항상 이렇게만 하자","author":"Dongha Kang","date":"2021-03-07","tag":["React","CSS"]},"slug":"rwd","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      pre: \"pre\",\n      code: \"code\",\n      p: \"p\",\n      h3: \"h3\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"Screen\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"@media screen and (orientation: landscape) {\\n  body::after {\\n    content: \\\"Landscape\\\";\\n  }\\n}\\n\\n@media screen and (orientation: portrait) {\\n  body::after {\\n    content: \\\"Portrait\\\";\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"// use this when it is image based site\\n@media (max-width: 400px) {\\n  // Styles for viewports narrower than 400 pixels.\\n}\\n\\n// use this when it is text based site\\n@media (min-width: 25em) {\\n  // Styles for viewports wider than 25em.\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Layout\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"레이아웃은 크게 두가지로 구분해서 디자인 하면 좋다. Macro 와 Micro Layout.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Macro 같은 경우 큰 레이아웃 즉 컴포넌트의 위치를 구성할 때 사용하면 좋고, Micro는 컴포넌트 안에서의 위치 이미지 위치 텍스트 위치 등 세분화된 구성요소를 구성할 때 사용한다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Macro\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"컴포넌트가 많으면 많을 수록 큰 틀을 Grid를 이용해서 만들어주자\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"@media (min-width: 45em) {\\n  main {\\n    display: grid;\\n    grid-template-columns: 2fr 1fr;\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Micro\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"컴포넌트 안에서는 grid 도 좋지만 flex box 도 잘 사용해보자\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \".media {\\n  display: flex;\\n  align-items: center;\\n  gap: 1em;\\n}\\n.media-illustration {\\n  flex: 1;\\n  max-inline-size: 200px;\\n}\\n.media-content {\\n  flex: 3;\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Typography\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"화면이 작으면 작을수록, 크면 클수록 텍스트의 크기를 변경하는것은 당연하다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"html {\\n  font-size: calc(0.75rem + 1.5vw);\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"⚠️ 직접적으로 vw 를 사용하면 resize 하기에 너무나도 어렵다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"html {\\n  font-size: clamp(1rem, 0.75rem + 1.5vw, 2rem);\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"clamp를 사용해서 최소의 텍스트 사이즈와, 최대의 텍스트 사이즈를 미리 정해버리자.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"max-inline-size 같은 경우도 텍스트 사이즈에 따라서 많이 변경되므로, px단위로 정하지 말자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"article {\\n  max-inline-size: 66ch;\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"line-height은 inline-size와 비례하게끔, px단위로 정하지 말자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"line-height: 1.5;\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"추가적인 기능\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"항상 overflow-x: hidden으로 정해놓고 옆으로 스크롤 하는 기능을 만들었었는데 사실 carousel이라는 기능이 있다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-css\",\n          children: \"@media (max-width: 50em) {\\n  .cards {\\n    display: flex;\\n    flex-direction: row;\\n    overflow-inline: auto;\\n    scroll-snap-type: inline mandatory;\\n    scroll-behavior: smooth;\\n  }\\n  .cards .card {\\n    flex-shrink: 0;\\n    flex-basis: 15em;\\n    scroll-snap-align: start;\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"구체적인 \", _jsx(_components.a, {\n          href: \"https://codepen.io/argyleink/pen/bGgyOGP\",\n          children: \"예시\"\n        })]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}