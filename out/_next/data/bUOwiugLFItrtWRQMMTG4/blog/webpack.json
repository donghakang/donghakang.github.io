{"pageProps":{"frontMatter":{"title":"Webpack 22222","author":"Dongha Kang","date":"2021-11-20","tag":["Webpack","JavaScript"]},"slug":"webpack","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      img: \"img\",\n      blockquote: \"blockquote\",\n      strong: \"strong\",\n      h2: \"h2\",\n      pre: \"pre\",\n      code: \"code\",\n      hr: \"hr\",\n      ul: \"ul\",\n      li: \"li\",\n      a: \"a\",\n      em: \"em\",\n      h3: \"h3\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/img/webpack.png\",\n          alt: \"Webpack\"\n        })\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Webpack\"\n          }), \"은 여러개의 파일들을 하나의 파일로 합쳐주는 module bundler 입니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Installation\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"npm init\\nnpm install --save-dev webpack webpack-cli\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"package.json\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"...\\n\\\"scripts\\\": {\\n  \\\"start\\\": \\\"webpack\\\"\\n}\\n...\\n\\\"devDependencies\\\": {\\n  \\\"webpack\\\": \\\"...\\\",\\n  \\\"webpack-cli\\\": \\\"...\\\"\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.p, {\n        children: [\"기존 방법은 아래와 같이 모든 파일들을 \", _jsx(_components.code, {\n          children: \"html\"\n        }), \" 파일에 때려박아야 했다. 그래야지 서로 서로가 필요한 \", _jsx(_components.code, {\n          children: \"function\"\n        }), \"들이나 필요한 코드들을 인용/사용할수 있었다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-html\",\n          children: \"<html>\\n...\\n  <script src=\\\"...\\\"></script>\\n  <script src=\\\"...\\\"></script>\\n  <script src=\\\"...\\\"></script>\\n  <script src=\\\"...\\\"></script>\\n</html>\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"하지만 \", _jsx(_components.code, {\n          children: \"npx create-react-app\"\n        }), \"을 사용해봐서 알겠지만, 그거는 정말로 안좋은 구성에 코드이며 순서가 상관이 있기 때문에 에러 또한 잘 날 수 밖에 없었다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"즉, Webpack을 사용하게 되면 import / export를 이용해서 다른 파일에서 수식이나 파일을 가져와서 사용할 수 있다.\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"🚀 Webpack Configuration\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Webpack configuration을 하지 않았던 지금은 \", _jsx(_components.code, {\n          children: \"index.js\"\n        }), \" 을 찾았었고 그 파일이 있으면 최초 진입 파일을 index.js 로, 없다면 error가 발생했다는 것을 확인 했었을것이다. 또한, webpack을 실행시키면, dist라는 폴더에 main.js라는 파일에 모듈화 된 파일을 저장했었다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 기본 설정을 바꾸기 위해서 webpack.config.js를 생성해주자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// webpack.config.js\\nconst path = require(\\\"path\\\");\\n\\nmodule.exports = {\\n  mode: \\\"development\\\",\\n  entry: \\\"./src/index.js\\\",\\n  output: {\\n  filename: \\\"main.js\\\",\\n  path: path.resolve(__dirname, \\\"dist\\\")\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"mode: 어떤 방식으로 배포(?) 할 건지도 고를 수 있다. production 이 default 이다. (production, development, none)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"entry: 최초의 시작 code. entrypoint\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"output: 배포시 생성되는 결과물\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"filename: 결과물, 파일 이름\"\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [\"path: 경로 (\", _jsx(_components.code, {\n                children: \"__dirname\"\n              }), \"은 현재 \", _jsx(_components.code, {\n                children: \"webpack.config.js\"\n              }), \"가 있는 폴더라고 생각하면 편하다. 실제로는 full path. 이것은 \", _jsx(_components.code, {\n                children: \"const path = require(”path”)\"\n              }), \"가 꼭 있어야지 작동한다\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"webpack.config.js\"\n        }), \"를 실행시키기 위해 package.json 도 수정한다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"...\\n\\\"scripts\\\": {\\n  \\\"start\\\": \\\"webpack --config webpack.config.js\\\"\\n}\\n...\\n\"\n        })\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"🚀 Loaders\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"loaders 는 js 파일 뿐만 아니라 다른 파일들을 import 할 수 있게끔 도와준다. (css, sass, svg 등등..)\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"loaders는 다양한 종류들이 있는데, style-loader, file-loader 등등... 그것은 \", _jsx(_components.a, {\n          href: \"https://webpack.js.org/loaders/\",\n          children: \"여기\"\n        }), \"에서 확인하면 된다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"css 를 한번 넣어보자!\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"우선 1, style-loader와 css-loader를 다운로드 받는다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"npm install --save-dev style-loader css-loader\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그 다음, 아래와 같이\", _jsx(_components.code, {\n          children: \"webpack.config.js\"\n        }), \" 에 추가적으로 css-loader와 style-loader를 .css로 정확하게 끝나는 파일들에 한에서 사용해주자.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"module.exports = {\\n  ...\\n  module: {\\n  rules: [\\n    {\\n    test: /\\\\.css$/,\\n    use: ['style-loader', 'css-loader'],\\n    }\\n  ]\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"⚠️\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"css-loader\"\n        }), \": css 코드를 가지고 javascript 파일에서도 eval 할 수 있게끔 도와준다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"style-loader\"\n        }), \": 변환된 javascript 파일을 이용해서 style을 해준다. Inject styles into DOM\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"순서도 상관있다. (뒤에부터 읽는다, css-loader를 읽고 style-loader로 적용한다)\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"당연히 sass는 sass-loader \", _jsx(_components.code, {\n          children: \"([”style-loader”, “css-loader”, “sass-loader”])\"\n        })]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"🚀 Cache Busting & Plugins\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"웹사이트를 들어갈때마다, 새로고침을 하던, 하드 새로고침을 해보면 Network 에 Cache가 저장된거를 가끔씩 본 적이 있을 것이다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"만약에 그 Cache가 업데이트 된 뒤에도 이전 Cache를 사용된다면 업데이트가 된 이후로도 예전 버전의 css 나 js 파일을 가지고 있을 것이다. 그 outdate 버전을 보여주는것을 방지하기 위해서 \", _jsx(_components.em, {\n          children: \"content hash\"\n        }), \"를 사용해보자!\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Cache busting을 사용함으로서 실제 코드를 바꾸면 output file을 새로운 파일 이름으로 지정해준다!\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// webpack.config.js\\nconst path = require(\\\"path\\\");\\n\\nmodule.exports = {\\n  entry: \\\"./src/index.js\\\",\\n  output: {\\n  filename: \\\"main.[contentHash].js\\\",\\n  path: path.resolve(__dirname, \\\"dist\\\")\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"main.[contentHash].js\"\n        }), \" 로 filename 을 바꿨기 때문에 cached version을 불러오지 않고 새로운 파일을 (main.jaiudvjic12390.js)을 불러온다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"하지만 문제는 \", _jsx(_components.code, {\n          children: \"index.html\"\n        }), \" 에 script로 추가 되었던 파일 이름은 예전처럼 main.js일텐데... 매번 main.contentHash.js로 바꾸어 주는것이 아니라 Plugins을 사용해서 index.html에 매번 바꿔준다.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"🚀 Plugins\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"방금 Cache Busting 에서 언급된 index.html에서 script를 자동으로 불러 오는 기능은 \", _jsx(_components.code, {\n          children: \"html-webpack-plugin\"\n        }), \"을 사용해주면 해결이 가능하다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"npm install --save-dev html-webpack-plugin\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"사용 방법은 아래와 같다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// webpack.config.js\\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\\nconst path = require(\\\"path\\\");\\n\\nmodule.exports = {\\n  entry: \\\"./src/index.js\\\",\\n  output: {\\n  filename: \\\"main.[contentHash].js\\\",\\n  path: path.resolve(__dirname, \\\"dist\\\")\\n  },\\n  plugins: [\\n  new HtmlWebpackPlugin(\\n    {\\n    template: \\\"./src/template.html\\\"\\n    }\\n  )\\n  ]\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"plugins: [new HtmlWebpackPlugin()]\"\n        }), \"  를 넣어 주고 dist (out directory)폴더를 보면 새로운 \", _jsx(_components.code, {\n          children: \"index.html\"\n        }), \"이 생긴것을 확인 할 수 있다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"argument인 \", _jsx(_components.code, {\n          children: \"template.html\"\n        }), \" 은 index.html와 비슷한 이미지 이고 그 이미지를 토대로 새로운 index.html을 dist 폴더 안에 넣어준다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"즉, plugin을 사용해서 index.html을 새롭게 만들어 줄수 있다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"미래에 CRA 형식 처럼 public 폴더, src 폴더를 따로 만들었다면 \", _jsx(_components.code, {\n          children: \"template.html\"\n        }), \"은 \", _jsx(_components.code, {\n          children: \"./public/index.html\"\n        }), \"로 변경 가능하다.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"Dev mode and Prod mode\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"webpack.config.js / webpack.common.js : General Configuration file\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"webpack.dev.js: Developement mode\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"webpack.prod.js: Production mode\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"곂치는 부분이 있을 수 있고 그것을 Production mode나, development에서 공유 할 수 있다. 그 공유되는 configuration파일을 합치는 방법이 있는데, 바로 webpack-merge를 사용하는 것이다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"npm install --save-dev webpack-merge\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// dev.js or prod.js\\nconst common = require('./webpack.common');\\nconst merge = require('weback-merge');\\n\\nmodule.exports = merge(common, {\\n  ...\\n});\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"prod.js 나 dev.js 파일을 가지고 있는 것만으로도 npm start, npm run build로 dev 모드, production 모드를 지정할 수 있다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"// package.json\\n{\\n  ...,\\n  \\\"scripts\\\": {\\n  \\\"start\\\": \\\"webpack --config webpack.dev.js\\\",\\n  \\\"build\\\": \\\"webpack --config webpack.prod.js\\\",\\n  }\\t\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"server\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"npm install --save-dev webpack-dev-server\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"// package.json\\n{\\n  ...,\\n  \\\"scripts\\\": {\\n  \\\"start\\\": \\\"webpack-dev-server --config webpack.dev.js --open\\\",\\n  \\\"build\\\": \\\"webpack --config webpack.prod.js\\\",\\n  }\\t\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"webpack-dev-server\"\n        }), \": 개발 서버로서 수정이 된 파일들을 실시간으로 업데이트 해주는 기능을 가지고 있다. (\", _jsx(_components.code, {\n          children: \"npm run build\"\n        }), \"처럼 새로운 파일을 생성 하지 않는다)\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"—-open\"\n        }), \": default 브라우저를 열어준다.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"🚀 Html-loader, file-loader\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이미지와 다른 형식의 파일들은 지금 까지 배운 정보로는 dist, build 폴더에 저장이 되지 않아서 build를 실행 했을때, 이미지/파일을 확인 할 수 가 없다. 물론 dist, build에 파일을 그대로 복사하는 방법도 있지만 어떻게 일일이 다 복붙을 할 수 있겠는가..\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"그래서 assets, img, 그런 폴더들을 build나 dist 폴더에 복사를 하는 방법을 알아보자.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"html-loader\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"예를 들어, \", _jsx(_components.code, {\n          children: \"<img src=”image.png”>\"\n        }), \" 가 있다면 \", _jsx(_components.code, {\n          children: \"require(’./image.png’)\"\n        }), \"를 무조건 실행시키고 그 파일을 어떻게 작동 할 건지 결정하는 역할을 한다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"npm install --save-dev html-loader\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// webpack.common.js\\nmodule.exports = {\\n  ...\\n  module: {\\n  rules: [\\n    {\\n    test: /\\\\.css$/,\\n    use: ['style-loader', 'css-loader'],\\n    },\\n    {\\n    test: /\\\\.html$/,\\n    use: ['html-loader']\\n    }\\n  ]\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이 상태에서 만약 \", _jsx(_components.code, {\n          children: \"index.html\"\n        }), \"이 \", _jsx(_components.code, {\n          children: \"<img src=”./assets/image.png”/>\"\n        }), \" 가 있었고, build를 한다면 어떤 일이 일어날까? ⇒ 바로 import를 하고, loader를 찾으라는 에러가 나온다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"그 의 알맞는 loader가 무엇일까?\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"file-loader\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"file-loader는 각종 다양한 파일들 (png, jpeg ...)를 읽어주는 것을 도와주는 loader이다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"npm install --save-dev file-loader\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// webpack.common.js\\nmodule.exports = {\\n  ...\\n  module: {\\n  rules: [\\n    ...,\\n    {\\n    test: /\\\\.(svg|png|jpg|gif)$/,\\n    use: {\\n      loader: \\\"file-loader\\\",\\n      options: {\\n      name: \\\"[name].[hash].[ext]\\\"\\n      outputPath: \\\"imgs\\\",\\n      }\\n    }\\n    }\\n  ]\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"name: “[name].[hash].[ext]”\"\n        }), \" : test에서 곧장 use를 쓰는 방법도 있지만, 다른 option들도 추가할 수 있다. 현재 option 같은 경우는 export할 때의 파일이름이 어떻게 달라지는지를 컨트롤한다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"outputPath\"\n        }), \": build를 하면 이름들도 바뀌고, 그 파일들을 지정 폴더에 넣는다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"즉, \", _jsx(_components.code, {\n          children: \"npm run build\"\n        }), \" 를 하면,\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"./dist/imgs/webpack.jiaovjcio23e4890.svg\"\n        }), \" 이라는 파일이 생성된다.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"Clean-webpack\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"hash 나 contentHash를 사용한다면 hash를 포함한 파일들이 계속해서 생성된다. 그래서 한번 정리해주는 plugin도 존재한다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"npm install --save clean-webpack-plugin\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"production 모드에만 사용하는 plugin이니, webpack.prod.js에 넣어보자\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const CleanWebpackPlugin = require('clean-webpack-plugin')\\n\\nmodule.exports = {\\n  ...\\n  plugins: [new CleanWebpackPlugin()]\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"Multiple Entry\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"module.exports = {\\n  entry: {\\n  main: \\\"./src/index.js\\\",\\n  vendor: \\\"./src/vendor.js\\\",\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Tip: 생성되는 파일이름을 \", _jsx(_components.code, {\n          children: \"main.[hash].js\"\n        }), \" 에서 \", _jsx(_components.code, {\n          children: \"[name].[hash].bundle.js\"\n        }), \"로 변경 해주자.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"[name]\"\n        }), \"은 vendor가 생성될 수 도 있기 때문에,\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"bundle\"\n        }), \"은 여러개의 entry가 합쳐졌기 때문에\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"예시 에서는 \", _jsx(_components.code, {\n          children: \"vendor.js\"\n        }), \" 에 \", _jsx(_components.code, {\n          children: \"import “bootstrap”\"\n        }), \" 한줄 만 넣었다, 그 줄 하나만 넣어도 \", _jsx(_components.code, {\n          children: \"index.html\"\n        }), \"에서는 당연히 main 뿐만 아니라 vendor도 같은 entry 에 있기 때문에 \", _jsx(_components.code, {\n          children: \"index.html\"\n        }), \"에서 \", _jsx(_components.code, {\n          children: \"import “bootstrap”\"\n        }), \"을 소환 할 수 있었던 것이다.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"Extract CSS and Minify html/javascript/css\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"지금 까지의 방식이라면 javascript로 불러올때, css가 javascript화 된 상태에서 css 데이터들을 불러온다. 즉 build 폴더에는 css 파일이 생성이 되지 않고 javascript안에서 해결한다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 것의 단점은 바로 처음 불러올때이다. 물론 속도가 빠르겠지만, 처음에 load를 할 때는 style이 되어있지 않은 javascript와 html을 뱉어버린다 🤮\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"mini-css-extract-plugin\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"npm install --save-dev mini-css-extract-plugin\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// webpack.prod.js\\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\\n\\nmodule.exports = {\\n  ...\\n  plugins: [\\n  new MiniCssExtractPlugin({filename: \\\"[name].[contentHash].css\\\"}),\\n  ...\\n  ],\\n  module: {\\n  rules: [\\n    {\\n    test: /\\\\.scss$/,\\n    use: [\\n      MiniCssExtractPlugin.loader,\\n      \\\"css-loader\\\",\\n      \\\"sass-loader\\\"\\n    ]\\n    }\\n  ]\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이렇게 사용한다면 build 폴더에 모든게 합쳐져 있는 1개의 hash css 파일도 생성이 되며, \", _jsx(_components.code, {\n          children: \"index.html\"\n        }), \" 에는 그것이 포함되어 있는 코드가 생성이 되어있다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"💡 다 좋은데, css 파일이 너어어어어무 길다면 ? \", _jsx(_components.strong, {\n          children: \"optimize-css-assets-webpack-plugin\"\n        }), \" (css 파일을 minify 해주는 Plugin.)\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const OptimizeCssAssetsPlugin = require(\\\"optimize-css-assets-webpack-plugin**\\\");**\\nmodule.exports = {\\n  ...\\n  optimization: {\\n  minimizer: [new OptimizeCssAssetsPlugin()]\\n  }\\n  ...\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"⚠  하지만, 이것을 사용한다면 기존에 minify 되었던 javascript가 이제는 Minify가 안된다는것을 확인 할 수 있다. 그래서 \", _jsx(_components.strong, {\n          children: \"terser-webpack-plugin\"\n        }), \"도 추가해야한다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const OptimizeCssAssetsPlugin = require(\\\"optimize-css-assets-webpack-plugin**\\\");**\\nconst TerserPlugin = require(\\\"terser-webpack-plugin\\\"**);**\\nmodule.exports = {\\n  ...\\n  optimization: {\\n  minimizer: [new OptimizeCssAssetsPlugin(), new TerserPlugin()]\\n  }\\n  ...\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"자, 그러면 html은 어떻게 minify 할까 ? \", _jsx(_components.code, {\n          children: \"HtmlWebpackPlugin\"\n        }), \" 을 사용하면 된다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"module.exports = {\\n  ...\\n  plugins: [\\n  new HtmlWebpackPlugin({\\n    template: \\\"./src/template.html\\\",\\n    minify: {\\n    removeAttributeQuotes: true,\\n    collapseWhitespace: true,\\n    removeComments: true\\n    }})]}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"확실히 CRA는 편리하게 시작할 수 있지만, Web 상에서 더 많은 관리와 내가 원하는 입 맛으로 설정을 하고 싶다면 무조건 webpack & babel을 써야한다고 생각한다.\\n본인 같은 경우는 markdown 파일을 CRA에서 읽으려고 할때 마음대로 되지 않았는데, webpack이라는 것을 알게 되고 문제를 한방에 해결할 수 있었다..\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"잘가라, CRA...\"\n      }), \"\\n\", _jsx(_components.blockquote, {\n        children: \"\\n\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}