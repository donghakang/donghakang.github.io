{"pageProps":{"frontMatter":{"title":"useMemo와 useCallback","author":"Dongha Kang","date":"2022-01-21","tag":["React","hook"]},"slug":"usememo-usecallback","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      h2: \"h2\",\n      pre: \"pre\",\n      strong: \"strong\",\n      ul: \"ul\",\n      li: \"li\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"useState\"\n        }), \", \", _jsx(_components.code, {\n          children: \"useEffect\"\n        }), \" 를 정말로 많이 쓰지만, 최근에 커뮤니티에 한분과 대화하는 과정에서 현업에서는 useCallback과 useMemo를 정말로 많이 쓴다고 해서 다시한 번 useMemo, useCallback을 잘 설명 할 수 있는 정도의 이해를 하려한다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"🦁 useMemo\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const memoizedResult = useMemo(() => {\\n  return expensiveFunction(a, b);\\n}, [a, b]);\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"useMemo는 \", _jsx(_components.strong, {\n          children: \"메모이제이션\"\n        }), \"된 값을 변환합니다. useMemo는 의존성이 변경되었을 때에만 메모이제이션된 값만 다시 계산할 것입니다. 이 최적화는 모든 렌더링 시의 고비용 계산을 방지하게 해줍니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \".. 가 무슨 말일까? 나는 예시가 더 편하다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"factorial을 구하는 코드가 있다고 생각하자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"function factorialFn(n) {\\n  console.log(\\\"factorial called\\\");\\n  return n <= 0 ? 1 : n * factorialFn(n - 1);\\n}\\n\\nfunction CalculateFactorial() {\\n  const [number, setNumber] = useState(1);\\n  const [num, setNum] = useState(0);\\n  const factorial = factorialFn(number);\\n  function onChange(e) {\\n  setNumber(Number(e.target.value));\\n  }\\n\\n  return (\\n  <div>\\n    <input type=\\\"number\\\" value={number} onChange={onChange} />! = {factorial}\\n    <button onClick={() => setNum((prevState) => prevState + 1)}>\\n    Re-render..\\n    </button>\\n  </div>\\n  );\\n}\\n\\nexport default CalculateFactorial;\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"number: factorial 하는 숫자,\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"num: 버튼을 누를때마다 올라가는 숫자\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"⚠️ React의 특징중 하나는, state값이나 props 값이 변경이 되면 그 component가 re-render되는 특징이 있다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"즉, useState 만 사용한 코드에서는 factorial이랑 관계가 없는 저 버튼! 버튼을 눌러도 factorial 값이 re-rendering 되기 때문에 \", _jsx(_components.code, {\n          children: \"factorial called\"\n        }), \" 라는 문구가 콘솔창에 뜬다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"위 상황에서 처럼 값비싼 function들을 돌릴때에는 매번 re-render를 하게 된다면 굉장히 느려질 것이다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"function factorialFn(n) {\\n  console.log(\\\"factorial called\\\");\\n  return n <= 0 ? 1 : n * factorialFn(n - 1);\\n}\\n\\nfunction CalculateFactorial() {\\n  const [number, setNumber] = useState(1);\\n  const [num, setNum] = useState(0);\\n  const factorial = useMemo(() => factorialFn(number), [number]);\\n\\n  function onChange(e) {\\n  setNumber(Number(e.target.value));\\n  }\\n\\n  return (\\n  <div>\\n    <input type=\\\"number\\\" value={number} onChange={onChange} />! = {factorial}\\n    <button onClick={() => setNum((prevState) => prevState + 1)}>\\n    Re-render..\\n    </button>\\n  </div>\\n  );\\n}\\n\\nexport default CalculateFactorial;\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"하지만 useMemo를 위의 코드처럼 이용하게 된다면, 불필요한 re-rendering이 멈췄다는 것을 알 수 있다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"즉, 위의 코드는 number 값이 바뀔때는 factorialFn이 re-rendering 없이 그 함수만 호출되는 것을 확인 할 수 있다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"🐯 useCallback\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const memoizedFunction = useCallback(() => {\\n  expensiveFunction(a, b);\\n}, [a, b]);\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"useMemo는 메모이제이션 값을, useCallback는 \", _jsx(_components.strong, {\n          children: \"메모이제이션 함수\"\n        }), \"를 뜻한다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"useCallback은 의존성이 변경되었을 때에만 변경된다. class 에서 사용할때의 shouldComponentUpdate처럼...\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"은 예시로 보자\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const List = ({ getItems }) => {\\n  const [items, setItems] = useState([]);\\n  useEffect(() => {\\n  setItems(getItems());\\n  console.log(\\\"render lists... \\\");\\n  }, [getItems]);\\n  return items.map((item) => <div key={item}>{item}</div>);\\n};\\n\\nfunction Parent() {\\n  const [number, setNumber] = useState(1);\\n  const [dark, setDark] = useState(false);\\n\\n  const getItems = () => {\\n  return [number, number + 1, number + 2];\\n  };\\n\\n  const theme = {\\n  backgroundColor: dark ? \\\"#333\\\" : \\\"#FFF\\\",\\n  color: dark ? \\\"#FFF\\\" : \\\"#333\\\",\\n  };\\n\\n  const onChange = (e) => {\\n  setNumber(parseInt(e.target.value));\\n  };\\n\\n  const onClick = () => {\\n  setDark((prevDark) => !prevDark);\\n  };\\n  return (\\n  <div style={theme}>\\n    <input type=\\\"number\\\" value={number} onChange={onChange} />\\n    <button onClick={onClick}>Toggle Theme</button>\\n    <List getItems={getItems} />\\n  </div>\\n  );\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"number: input type 에서 지정해주는 숫자\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"dark: 테마를 변경해주는 boolean 값.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"지금 useCallback을 사용하지 않은 경우, 테마를 바꾸는 버튼을 누를시 Parent 컴포넌트가 다시 렌더링 되서 getItems 를 다시 호출 시키는데, 그 과정에서 getItems를 Props로 받던 List 또한 다시 렌더링이 된다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"지금 같은 경우 getItems가 그냥 덧셈 밖에 없지만, 만약에 통신같은 비싼 함수 값이라면 불필요한 로딩 타임이 소요 될 수도 있다. 그러면 getItems 를 한번 바꿔보자\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const List = ({ getItems }) => {\\n  const [items, setItems] = useState([]);\\n  useEffect(() => {\\n  setItems(getItems());\\n  console.log(\\\"render list... \\\");\\n  }, [getItems]);\\n  return items.map((item) => <div key={item}>{item}</div>);\\n};\\n\\nfunction Parent() {\\n  const [number, setNumber] = useState(1);\\n  const [dark, setDark] = useState(false);\\n\\n  const getItems = useCallback(() => {\\n  return [number, number + 1, number + 2];\\n  }, [number]);\\n\\n  const theme = {\\n  backgroundColor: dark ? \\\"#333\\\" : \\\"#FFF\\\",\\n  color: dark ? \\\"#FFF\\\" : \\\"#333\\\",\\n  };\\n\\n  const onChange = (e) => {\\n  setNumber(parseInt(e.target.value));\\n  };\\n\\n  const onClick = () => {\\n  setDark((prevDark) => !prevDark);\\n  };\\n  return (\\n  <div style={theme}>\\n    <input type=\\\"number\\\" name=\\\"\\\" id=\\\"\\\" value={number} onChange={onChange} />\\n    <button onClick={onClick}>Toggle Theme</button>\\n    <List getItems={getItems} />\\n  </div>\\n  );\\n}\\n\\nexport default App;\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이렇게 변경해주면 render list... 라는 문구는 테마가 바뀔 때에는 호출되지 않는다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"useCallback 같은 경우는 통신이 사용 될 시, 혹은 \", _jsx(_components.a, {\n          href: \"https://dmitripavlutin.com/dont-overuse-react-usecallback/\",\n          children: \"이 케이스\"\n        }), \"처럼 React.memo로 묶인 최적화된 자식 컴포넌트의 함수로 선언해줄때 효율 적이다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"💁🏻‍♂️ React.memo\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"React.memo 로 래핑이 되는 컴포넌트는 메모이징 되는 컴포넌트, props가 변경되기 전까지 리-렌더링을 방지하며 컴포넌트의 렌더링 성능을 최적화 해주는 컴포넌트로 변환 된다\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"기존에 useMemo는 한 값을 메모이징 했다면, React.memo로 묶음 으로서 component 자체를 메모이징 할 수 있다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"function Component(props) {\\n  return <div>React.memo</div>;\\n}\\n\\nexport default React.memo(MyBigList);\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 React.memo 컴포넌트를 성공적으로 만들었다면, memoized 컴포넌트에는 useCallback을 보내줌으로서 렌더 최적화를 시킬 수 있다. 아래는 그에 관련된 예시이다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"const Parent = () => {\\n  const [isClicked, setIsClicked] = useState(false);\\n  const handleClick = useCallback(() => {\\n  setIsClicked(true);\\n  }, []);\\n\\n  return (\\n  <>\\n    <Child onClick={handleClick} />\\n    <Child onClick={handleClick} />\\n    <Child onClick={handleClick} />\\n    ...\\n  </>\\n  );\\n};\\n\\nconst Child = React.memo(({ onClick }) => {\\n  return <button onClick={onClick}>Click Me!</button>;\\n});\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"⚠️ React.memo의 props 가 변경되면 re-rendering 되는 것은 맞지만, 변경 여부는 shallow compare로서 (object 같은 경우 value 값이 한개만 바뀌어도 다시 리-렌더링) 그것을 예방하고 싶으면 React.memo에 다 추가적인 함수를 넣어도 된다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"function MyComponent(props) {\\n  /* 컴포넌트 로직 */\\n}\\nfunction areEqual(prevProps, nextProps) {\\n  // props 두개가 동일 하면 true.\\n  // false 인 경우 리렌더링을 시킨다 ==> shouldComponentUpdate 의 정반대\\n}\\n\\nexport default React.memo(MyComponent, areEqual);\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"🤬 이럴땐 쓰지마세요!\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"useCallback, useMemo 또한 단점이 있다. 두 개 의 함수 같은 경우 Wrapping function, 묶여 있는 함수와 비슷하기 때문에, 메모제이션용 메모리를 추가적으로 사용하게 됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"당 연 히 많이 사용하면 덜 사용한거보다 메모리를 더 사용할 수 있기 때문에 엄청나게 복잡한 function이 아니라면 웬만하면 피하는것이 좋다\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}