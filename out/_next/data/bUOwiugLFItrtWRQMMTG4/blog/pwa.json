{"pageProps":{"frontMatter":{"title":"PWA🗂에 대하여","author":"Dongha Kang","date":"2022-03-08","tag":["Service Worker","PWA"]},"slug":"pwa","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      img: \"img\",\n      h2: \"h2\",\n      strong: \"strong\",\n      h3: \"h3\",\n      ol: \"ol\",\n      pre: \"pre\",\n      code: \"code\",\n      hr: \"hr\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"PWA란, 앱처럼 보여지는 웹 어플리케이션이라고 이해할 수 있다. 특징으로서는\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"홈 스크린 아이콘을 생성할 수 있으며, app launcher, launchpad, 시작 메뉴까지 전부 설정 가능하다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"어플리케이션을 검색할때도 찾을 수 있다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"standalone으로 사용 할 수 있으며, 브라우저 인터페이스와도 독립 시킬 수 있다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"OS에 알맞게 설정도 가능하다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"offline상에서도 실행 가능하다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Push 메시지나 알림 같은 기능 구현 가능\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"웹 앱인데도 불구하고!\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"그 전에 Web 과 Platform app의 장단점에 대해서 알아보자면\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Web의 장점\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"연결성, 접근성, 배포, 업데이트, 퍼블리싱\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Platform의 장점\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"오프라인, 디바이스 연결성, 아이콘, standalone, 퍼포먼스\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"PWA의 시작은 아마 이 모든 것을 해결하기 위해서일 것이다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/img/pwa1.png\",\n          alt: \"PWA 예시\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"데이터 저장/불러오기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"platform으로 실행하는 앱 같은 경우 미리 다운로드를 해서 앱이 가지고 있는 Assets과 data를 다운로드 시킨다. 그래서 app으로 사용할 때, 오프라인일 때도 기본적인 assets과 data들을 사용할 수는 있다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"반면에, web application은 url에 들어갈때마다 assets과 data를 다운로드 하기 때문에 assets이 없는 클라이언트를 만 보여지게 된다. (즉, 항상 네트워크가 필요하다)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Web 어플리케이션이 발전하면서 Cache와 저장기능또한 발전했는데. PWA는 아래오와같은 기능들을 사용한다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Web Storage: localStorage 와 sessionStorage. key value 값을 string으로 저장해서 web에 저장하는 기능이다. 물론 용량은 제한적이다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"indexedDB: (No-SQL 기반) binary data client-side. API request로 받거나 보내는 것을 저장할 때 주로 사용된다. IndexedDB API도 있어서 db 관리 할 때도 유용하다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Cache Storage: HTTP request와 response 짝을 저장 및 검색할 수 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"PWA는 이 기능들을 사용할 수는 있지만, \", _jsx(_components.strong, {\n          children: \"service workers\"\n        }), \" 라는 기능으로 더 업그레이드 시킬 수 있다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"service workersms\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"network 필요없이 assets를 가져올 수 있다\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"사용자에게 알림을 준다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"PWA 아이콘에 뱃지를 달 수 있다\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"업데이트 가능하다\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"PWA가 오프라인으로 일 할 수있는 가장 큰 역할을 한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"service workers\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/img/service-worker.png\",\n          alt: \"service worker 블루 프린트\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"service worker는 어플리케이션이 request를 보낼 때, 마치 네트워크 프록시 처럼 (오프라인일때도) request를 받아서 Cache storage API에서 정보를 받아올지, 네트워크를 이용하여 정보를 받아올지, 혹은 local 알고리즘으로 정보를 받아올 지 정하는 역할을 한다. 마치 platform 앱들 처럼. 더 나아가 service workers는 이러한 일들 도 가능하게 만든다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"오프라인으로 콘텐트 불러오기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"background sync\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"push notification\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"life cycle\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"main.js 에서 service worker를 언급하며 등록(register)을 한다. (혹은 index.html에서 바로...)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"register후 event를 install 한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"install을 하면 service worker가 activate 된다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"event 를 active 시킨다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"service worker가 event를 확인하고 response를 감지하기 시작한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"⚠️ service worker가 바뀌지 않는다면 2, 3, 4는 실행되지 않는다. 만약 service worker가 업데이트 된다면 2,3,4는 다시 실행이 된다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"code\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// main.js\\n\\n// Register\\nif (\\\"serviceWorker\\\" in navigator) {\\n  console.log(\\\"Service Worker supported\\\");\\n  window.addEventListener(\\\"load\\\", () => {\\n    navigator.serviceWorker\\n      .register(\\\"sw.js\\\")\\n      .then((reg) => console.log(\\\"Service worker registered\\\", reg))\\n      .catch((err) => console.warn(\\\"Service worker Error\\\", err));\\n  });\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// sw.js\\n\\n// default cache\\nconst cacheName = \\\"v1\\\";\\n\\nconst cacheAssets = [\\n  \\\"index.html\\\",\\n  \\\"about.html\\\",\\n  \\\"/css/style.css\\\",\\n  \\\"/js/main.js\\\",\\n];\\n\\n// Install\\nself.addEventListener(\\\"install\\\", (e) => {\\n  console.log(\\\"Service worker installed\\\");\\n\\n  e.waitUntil(\\n    caches\\n      .open(cacheName)\\n      .then((cache) => {\\n        console.log(\\\"Service Worker: Caching files\\\");\\n        cache.addAll(cacheAssets);\\n      })\\n      .then(() => {\\n        self.skipWaiting();\\n      }) //여기 까지 진행이 된다면 Cache Storage에 cache Assets가 저장이 된다.\\n  ); // promise가 끝날때 까지 기다린다\\n});\\n\\n// Activate\\nself.addEventListener(\\\"activate\\\", (e) => {\\n  console.log(\\\"Service Worker activated\\\");\\n\\n  // Remove unwanted caches\\n  e.waitUntil(\\n    caches.keys().then((cacheNames) => {\\n      return Promise.all(\\n        cachesNames.map((cache) => {\\n          if (cache !== cacheName) {\\n            // cache 이름이 같지 않다면 옛날 캐쉬를 지운다.\\n            console.log(\\\"Service Worker: Clearing old cache\\\");\\n            return caches.delete(cache);\\n          }\\n        })\\n      );\\n    })\\n  );\\n}); // 옛날 캐시들을 지우고 새로운 버전을 덮는다.\\n\\n// Call fetch event\\nself.addEventListener(\\\"fetch\\\", (e) => {\\n  console.log('Service Worker: Fetcdhing...\\\"');\\n  e.respondWith(\\n    fetch(e.request).catch(() => caches.match(e.request)) // Cache 에 있는 데이터를 가져오기 때문에 컨낵션이 없어도 화면을 볼 수 있따.\\n  );\\n});\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"또다른 방식으로는 cache에 모든 response를 다 받아오는 방법이 하나 더 있다. 페이지(파일)을 하나 하나 다 cacheNames로 언급할 필요 없이 모든 페이지를 (방문한) 전부 cache에 저장하는 방법이 있다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"// default cache\\nconst cacheName = \\\"v2\\\";\\n\\n// Install\\nself.addEventListener(\\\"install\\\", (e) => {\\n  console.log(\\\"Service worker installed\\\");\\n});\\n\\n// Activate\\nself.addEventListener(\\\"activate\\\", (e) => {\\n  console.log(\\\"Service Worker activated\\\");\\n\\n  // Remove unwanted caches\\n  e.waitUntil(\\n    caches.keys().then((cacheNames) => {\\n      return Promise.all(\\n        cachesNames.map((cache) => {\\n          if (cache !== cacheName) {\\n            // cache 이름이 같지 않다면 옛날 캐쉬를 지운다.\\n            console.log(\\\"Service Worker: Clearing old cache\\\");\\n            return caches.delete(cache);\\n          }\\n        })\\n      );\\n    })\\n  );\\n}); // 옛날 캐시들을 지우고 새로운 버전을 덮는다.\\n\\n// Call fetch event\\nself.addEventListener(\\\"fetch\\\", (e) => {\\n  console.log('Service Worker: Fetcdhing...\\\"');\\n  e.respondWith(\\n    fetch(e.request)\\n      .then((res) => {\\n        // Make copy/clone of response\\n        const resClone = res.clone();\\n\\n        // Open cache\\n        caches.open(cacheName).then((cache) => {\\n          // Add response to cache\\n          cache.put(e.request, resClone);\\n        });\\n        return res;\\n      })\\n      .catch((err) => caches.match(e.request).then((res) => res))\\n  );\\n});\\n\"\n        })\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"Caching\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이제 cache storage가 pwa에서 얼마나 중요한지 알아 냈다면, 무엇을 caching 해야할까?\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"main html\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"css\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"UI에 사용되는 이미지들\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"UI에 사용되는 javascript\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"기본 데이터 (JSON)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"폰트\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"SPA가 아닌 상황에서 빠른 page 변경이 필요할때\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Service Worker는 이 페이지에서 감당하기에는 너무나도 많은 이야기 이니깐... \", _jsx(_components.a, {\n          href: \"https://web.dev/learn/pwa/\",\n          children: \"여기\"\n        }), \"에서 확인해주자...\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"나중에는 Workbox도 한번 공부 해보자 .. (32%가 사용하는 service workers 라이브러리 라는데 ...)\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"React & PWA\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"React 도 비슷하게 진행이 되기 때문에 \", _jsx(_components.a, {\n          href: \"https://github.com/donghakang/practice-react/tree/master/ex33-pwa\",\n          children: \"source code\"\n        }), \" 를 보면서 PWA를 만들어보자!\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}