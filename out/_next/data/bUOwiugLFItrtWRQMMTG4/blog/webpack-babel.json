{"pageProps":{"frontMatter":{"title":"Webpack + Babel","author":"Dongha Kang","date":"2021-11-20","tag":["Webpack","Babel","JavaScript"]},"slug":"webpack-babel","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      blockquote: \"blockquote\",\n      h1: \"h1\",\n      strong: \"strong\",\n      ul: \"ul\",\n      li: \"li\",\n      h2: \"h2\",\n      ol: \"ol\",\n      code: \"code\",\n      pre: \"pre\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"CRA는 너무나도 고마운 존재이지만 한계가 있었다. 나같은 경우는 file을 제대로 불러오지 못한다는점과 dev 모드와 production 모드에 포트 넘버를 바꾼다던가 ... 그런 일들과 마주쳤을때 글을 읽었다\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"님 왜 CRA 쓰셈?\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"👨🏻‍💻 Webpack 이란\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"webpack은 \", _jsx(_components.strong, {\n          children: \"module bundler\"\n        }), \" 이다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"html 파일에 들어가는 javascript 파일들을 하나의 자바 스크립트 파일로 만들어 주는 방식을 module bundler 라고 하며, 그것을 도와주는 bundler중 하나가 webpack이라는 것이다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"CRA을 쓰는 이유 중 제일 큰이유는 바로 SPA (single page application) 인데, webpack 을 사용함으로서 html 페이지에 여러가지 javascript파일들을 한 곳에 모아버릴수 있다. 즉, 이게 바로 SPA module bundling 이라는 것이다. 즉, \", _jsx(_components.strong, {\n          children: \"SPA를 만들기 위해 javascript 파일들을 모을 때 주로 사용한다.\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"또한, \", _jsx(_components.strong, {\n          children: \"파일을 컴파일 하는 시간도 단축\"\n        }), \"시켜주고 (여러개의 파일들 X), \", _jsx(_components.strong, {\n          children: \"웹페이지 성능 최적화\"\n        }), \"도 해준다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"즉,\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Webpack = Module bundler = multiple javascript files ⇒ 1 webpack\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"장점\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"SPA: 한 개의 html 페이지에 여러개의 자바스크립트 파일들\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"컴파일시 javascript 파일들 모아줌\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"웹페이지 성능 최적화\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"단점이라곤... 러닝 커브가 좀 높다는거 ?\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Webpack의 속성\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: _jsx(_components.strong, {\n              children: \"Entry\"\n            })\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [\"Entry는 최저 자바스크립트 파일경로이다. (대충... \", _jsx(_components.code, {\n              children: \"index.js\"\n            }), \"가 될 듯한데). 이 Entry로 모든 파일들을 하나의 파일로 묶어버린다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: _jsx(_components.strong, {\n              children: \"Output\"\n            })\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [\"Entry에서 찾은 모듈을 하나의 js 파일로 묶어버릴 위치를 설정한다. 대부분 '\", _jsx(_components.code, {\n              children: \"./build\"\n            }), \"', '\", _jsx(_components.code, {\n              children: \"./dist\"\n            }), \"' 와 같은 곳으로 지정한다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: _jsx(_components.strong, {\n              children: \"Loader\"\n            })\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [\"Webpack은 기본적으로 \", _jsx(_components.code, {\n              children: \"js\"\n            }), \" 파일만 지원을 한다. 그래서 \", _jsx(_components.code, {\n              children: \"js\"\n            }), \"뿐만 아니라 \", _jsx(_components.code, {\n              children: \"jsx\"\n            }), \", \", _jsx(_components.code, {\n              children: \"ts\"\n            }), \", \", _jsx(_components.code, {\n              children: \"tsx\"\n            }), \" 심지어 \", _jsx(_components.code, {\n              children: \"css\"\n            }), \"까지 읽고 빌드 할 수 있도록 지원 해주는 속성이다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: _jsx(_components.strong, {\n              children: \"Plugin\"\n            })\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [\"웹팩의 기본적인 설정 외 다른 \", _jsx(_components.code, {\n              children: \"loader\"\n            }), \"나 plugin을 설정 해줄수 있다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"👨🏻‍💻 Babel 이란?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Babel은 자바스크립트 ES6 문법을 ES5로 변환 시켜주는 transpiler이다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"ES6는 굉장히 신선하고 많은 브라우저들이 호환을 해준다. 근데, 왜 최신 ES6을 안사용하냐고? 아직도 세상에 11%는 익스플로러를 사용하고 있기 때문이다....\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"🚀 React without create-react-app\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"본격적으로 시작해 볼 예정이다. 우선 react-typescript로 만들계획이다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"mkdir <react-project> && cd <react-project>\\nnpm init -y                   # package.json 초기 설정\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"yarn add react react-dom                                # react download\\nyarn add -D typescript @types/react @types/react-dom    # devDependencies\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"tsc --init                    # tsconfig.json 초기 설정\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"# babel 설정\\nyarn add -D @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript @babel/plugin-transform-runtime\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"# webpack 설정\\nyarn add -D webpack-dev-server webpack-cli webpack\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}