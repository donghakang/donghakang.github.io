---
title: PWA🗂에 대하여
author: "Dongha Kang"
date: "2021-03-08"
tag: ["Service Worker", "PWA"]
---

PWA란, 앱처럼 보여지는 웹 어플리케이션이라고 이해할 수 있다. 특징으로서는

- 홈 스크린 아이콘을 생성할 수 있으며, app launcher, launchpad, 시작 메뉴까지 전부 설정 가능하다.
- 어플리케이션을 검색할때도 찾을 수 있다.
- standalone으로 사용 할 수 있으며, 브라우저 인터페이스와도 독립 시킬 수 있다.
- OS에 알맞게 설정도 가능하다.
- offline상에서도 실행 가능하다.
- Push 메시지나 알림 같은 기능 구현 가능

웹 앱인데도 불구하고!

그 전에 Web 과 Platform app의 장단점에 대해서 알아보자면

Web의 장점

- 연결성, 접근성, 배포, 업데이트, 퍼블리싱

Platform의 장점

- 오프라인, 디바이스 연결성, 아이콘, standalone, 퍼포먼스

PWA의 시작은 아마 이 모든 것을 해결하기 위해서일 것이다.

![PWA 예시](/img/pwa1.png)

## 데이터 저장/불러오기

platform으로 실행하는 앱 같은 경우 미리 다운로드를 해서 앱이 가지고 있는 Assets과 data를 다운로드 시킨다. 그래서 app으로 사용할 때, 오프라인일 때도 기본적인 assets과 data들을 사용할 수는 있다.

반면에, web application은 url에 들어갈때마다 assets과 data를 다운로드 하기 때문에 assets이 없는 클라이언트를 만 보여지게 된다. (즉, 항상 네트워크가 필요하다)

Web 어플리케이션이 발전하면서 Cache와 저장기능또한 발전했는데. PWA는 아래오와같은 기능들을 사용한다.

- Web Storage: localStorage 와 sessionStorage. key value 값을 string으로 저장해서 web에 저장하는 기능이다. 물론 용량은 제한적이다.
- indexedDB: (No-SQL 기반) binary data client-side. API request로 받거나 보내는 것을 저장할 때 주로 사용된다. IndexedDB API도 있어서 db 관리 할 때도 유용하다.
- Cache Storage: HTTP request와 response 짝을 저장 및 검색할 수 있다.

PWA는 이 기능들을 사용할 수는 있지만, **service workers** 라는 기능으로 더 업그레이드 시킬 수 있다.

service workersms

- network 필요없이 assets를 가져올 수 있다
- 사용자에게 알림을 준다.
- PWA 아이콘에 뱃지를 달 수 있다
- 업데이트 가능하다
- PWA가 오프라인으로 일 할 수있는 가장 큰 역할을 한다.

## service workers

![service worker 블루 프린트](/img/service-worker.png)

service worker는 어플리케이션이 request를 보낼 때, 마치 네트워크 프록시 처럼 (오프라인일때도) request를 받아서 Cache storage API에서 정보를 받아올지, 네트워크를 이용하여 정보를 받아올지, 혹은 local 알고리즘으로 정보를 받아올 지 정하는 역할을 한다. 마치 platform 앱들 처럼. 더 나아가 service workers는 이러한 일들 도 가능하게 만든다.

- 오프라인으로 콘텐트 불러오기
- background sync
- push notification

### life cycle

1. main.js 에서 service worker를 언급하며 등록(register)을 한다. (혹은 index.html에서 바로...)
2. register후 event를 install 한다.
3. install을 하면 service worker가 activate 된다.
4. event 를 active 시킨다.
5. service worker가 event를 확인하고 response를 감지하기 시작한다.

⚠️ service worker가 바뀌지 않는다면 2, 3, 4는 실행되지 않는다. 만약 service worker가 업데이트 된다면 2,3,4는 다시 실행이 된다.

### code

```jsx
// main.js

// Register
if ("serviceWorker" in navigator) {
  console.log("Service Worker supported");
  window.addEventListener("load", () => {
    navigator.serviceWorker
      .register("sw.js")
      .then((reg) => console.log("Service worker registered", reg))
      .catch((err) => console.warn("Service worker Error", err));
  });
}
```

```jsx
// sw.js

// default cache
const cacheName = "v1";

const cacheAssets = [
  "index.html",
  "about.html",
  "/css/style.css",
  "/js/main.js",
];

// Install
self.addEventListener("install", (e) => {
  console.log("Service worker installed");

  e.waitUntil(
    caches
      .open(cacheName)
      .then((cache) => {
        console.log("Service Worker: Caching files");
        cache.addAll(cacheAssets);
      })
      .then(() => {
        self.skipWaiting();
      }) //여기 까지 진행이 된다면 Cache Storage에 cache Assets가 저장이 된다.
  ); // promise가 끝날때 까지 기다린다
});

// Activate
self.addEventListener("activate", (e) => {
  console.log("Service Worker activated");

  // Remove unwanted caches
  e.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cachesNames.map((cache) => {
          if (cache !== cacheName) {
            // cache 이름이 같지 않다면 옛날 캐쉬를 지운다.
            console.log("Service Worker: Clearing old cache");
            return caches.delete(cache);
          }
        })
      );
    })
  );
}); // 옛날 캐시들을 지우고 새로운 버전을 덮는다.

// Call fetch event
self.addEventListener("fetch", (e) => {
  console.log('Service Worker: Fetcdhing..."');
  e.respondWith(
    fetch(e.request).catch(() => caches.match(e.request)) // Cache 에 있는 데이터를 가져오기 때문에 컨낵션이 없어도 화면을 볼 수 있따.
  );
});
```

또다른 방식으로는 cache에 모든 response를 다 받아오는 방법이 하나 더 있다. 페이지(파일)을 하나 하나 다 cacheNames로 언급할 필요 없이 모든 페이지를 (방문한) 전부 cache에 저장하는 방법이 있다.

```jsx
// default cache
const cacheName = "v2";

// Install
self.addEventListener("install", (e) => {
  console.log("Service worker installed");
});

// Activate
self.addEventListener("activate", (e) => {
  console.log("Service Worker activated");

  // Remove unwanted caches
  e.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cachesNames.map((cache) => {
          if (cache !== cacheName) {
            // cache 이름이 같지 않다면 옛날 캐쉬를 지운다.
            console.log("Service Worker: Clearing old cache");
            return caches.delete(cache);
          }
        })
      );
    })
  );
}); // 옛날 캐시들을 지우고 새로운 버전을 덮는다.

// Call fetch event
self.addEventListener("fetch", (e) => {
  console.log('Service Worker: Fetcdhing..."');
  e.respondWith(
    fetch(e.request)
      .then((res) => {
        // Make copy/clone of response
        const resClone = res.clone();

        // Open cache
        caches.open(cacheName).then((cache) => {
          // Add response to cache
          cache.put(e.request, resClone);
        });
        return res;
      })
      .catch((err) => caches.match(e.request).then((res) => res))
  );
});
```

---

## Caching

이제 cache storage가 pwa에서 얼마나 중요한지 알아 냈다면, 무엇을 caching 해야할까?

- main html
- css
- UI에 사용되는 이미지들
- UI에 사용되는 javascript
- 기본 데이터 (JSON)
- 폰트
- SPA가 아닌 상황에서 빠른 page 변경이 필요할때

Service Worker는 이 페이지에서 감당하기에는 너무나도 많은 이야기 이니깐... [여기](https://web.dev/learn/pwa/)에서 확인해주자...

나중에는 Workbox도 한번 공부 해보자 .. (32%가 사용하는 service workers 라이브러리 라는데 ...)

---

## React & PWA

React 도 비슷하게 진행이 되기 때문에 [source code](https://github.com/donghakang/practice-react/tree/master/ex33-pwa) 를 보면서 PWA를 만들어보자!
