---
title: Next.js와 Firebase Analytics
author: "Dongha Kang"
date: "2022-03-18"
tag: ["React"]
---

## 이 글을 읽었으면 하는 분들

- 자신의 Next.js 프로젝트에 Firebase Analytics을 넣고 싶은 👨🏻‍💻
- 페이지가 바뀔 때마다 Firebase analytics realtime 반응을 확인 하고 싶은 👨🏻‍💻
- 자신의 Next.js 프로젝트를 vercel 뿐만 아니라 Github Pages에 배포하고 싶은 👨🏻‍💻

## 🔥 Firebase installation

Firebase 초기 설정은 많이 찾아보면 나오기 때문에 긴 설명을 생략해도 될 것 같다. (Firebase 웹사이트 들어가고, 콘솔에 새로운 프로젝트 만들고, 프로젝트 세팅에서 configuration에서 config 데이터만 가져오면 된다 ... 주저리주저리 ...)

```javascript
const firebaseConfig = {
  apiKey: "XXXXXXXXXXXXXXXXX",
  authDomain: "XXXXXXXXXXXXXXXXX",
  projectId: "XXXXXXXXXXXXXXXXX",
  storageBucket: "XXXXXXXXXXXXXXXXX",
  messagingSenderId: "XXXXXXXXXXXXXXXXX",
  appId: "XXXXXXXXXXXXXXXXX",
  measurementId: "XXXXXXXXXXXXXXXXX",
};
```

그리고 firebase를 다운 받아준다. (블로그 기준 v9.6.8)

```bash
yarn add firebase
```

---

## 🔥 Firebase Context

깃헙과 스택 오버플로우를 찾아보면서 제일 좋은 아이디어라고 생각 한 것을 내 프로젝트에 넣어봤고 효과는 뛰어 나서 여기에 공유한다.
기존에, 그냥 analytics를 import 하는 방법 보다는 코드 읽기가 수월 했는데, 그 방법은 `useContext`를 사용하는 방법이었다.

```javascript
import firebase from "firebase/compat/app";
import "firebase/compat/analytics";
```

여기서 **compat를 넣은 이유는 `v9`** 라서 그런거고 v8을 사용하고 싶다면 compat를 빼면 그대로 된다.

```javascript
if (firebase.apps.length === 0) {
  const firebaseConfig = {
    apiKey: process.env.NEXT_PUBLIC_API_KEY,
    authDomain: process.env.NEXT_PUBLIC_AUTH_DOMAIN,
    projectId: process.env.NEXT_PUBLIC_PROJECT_ID,
    storageBucket: process.env.NEXT_PUBLIC_STORAGE_BUCKET,
    messagingSenderId: process.env.NEXT_PUBLIC_MESSAGING_SENDER_ID,
    appId: process.env.NEXT_PUBLIC_APP_ID,
    measurementId: process.env.NEXT_PUBLIC_MEASUREMENT_ID,
  };
  firebase.initializeApp(firebaseConfig);
}
```

firebase가 이미 initialized 되어 있는지 확인하고, 만약에 initialized가 되어 있지 않다면 firebase Config를 가져와서 firebase를 initialize 합니다.
여기서 가져온 `process.env.________` 들은 전부 프로젝트 루트에 .env 파일에 있는 값들이며, .env 파일에 쩌 위에서 받아온 firebase config를 넣으면 된다.
저렇게 데이터를 넣는 이유는 당연히 보안 문제이고 .env 파일은 github에 push 하면 안되니깐.. 😅

```javascript
export const FirebaseContext =
  (createContext < firebase.analytics.Analytics) | (null > null);
```

Firebase Context 를 설정해줍니다. type은 firebase가 initialize에 실패하면 `null`, 성공하면 `firebase.analytics.Analytics` 가 됩니다.

```javascript
const FirebaseTrackingProvider = (props: { children: ReactNode }) => {
  const router = useRouter();
  const [tracking, setTracking] =
    (useState < firebase.analytics.Analytics) | (null > null);

  useEffect(() => {
    setTracking(firebase.analytics());

    const handleRouteChange = (url: string) => {
      if (!tracking) {
        return;
      }
      tracking.logEvent("page_view", {
        page_location: url,
      });
    };

    router.events.on("routeChangeStart", handleRouteChange);

    return () => {
      router.events.off("routeChangeStart", handleRouteChange);
    };
  }, [tracking, router]);

  return (
    <FirebaseContext.Provider value={tracking}>
      {props.children}
    </FirebaseContext.Provider>
  );
};
export const useFirebase = () => useContext(FirebaseContext);

export default FirebaseTrackingProvider;
```

- `useEffect`안에 보시면 `firebase.analytics()`를 tracking과 router가 바뀔때 마다 `useState`를 이용해 업데이트 합니다.
- `routeChangeStart`(router 가 변경 될 시 작동되는 next.js의 이벤트)가 실행되면 `handleRouteChange`를 부르고, 그 때 tracking (`firebase.analytics.Analytics`) 의 `logEvent`를 부릅니다.
- `logEvent`에서 잘 알겠지(?)만, logEvent의 첫 input은 Event name을 두번째 input은 Event parameter가 됩니다.
- 이 모든 Context를 묶어서 useContext와 같이 export 하면 나중에 `_app.ts`에서 사용하기만 하면 끝.

아래는 전체 파일입니다

```javascript
// context/FirebaseContext.tsx

import {
  createContext,
  useState,
  useEffect,
  ReactNode,
  useContext,
} from "react";
import firebase from "firebase/compat/app";
import { useRouter } from "next/router";
import "firebase/compat/analytics";

if (firebase.apps.length === 0) {
  const firebaseConfig = {
    apiKey: process.env.NEXT_PUBLIC_API_KEY,
    authDomain: process.env.NEXT_PUBLIC_AUTH_DOMAIN,
    projectId: process.env.NEXT_PUBLIC_PROJECT_ID,
    storageBucket: process.env.NEXT_PUBLIC_STORAGE_BUCKET,
    messagingSenderId: process.env.NEXT_PUBLIC_MESSAGING_SENDER_ID,
    appId: process.env.NEXT_PUBLIC_APP_ID,
    measurementId: process.env.NEXT_PUBLIC_MEASUREMENT_ID,
  };
  firebase.initializeApp(firebaseConfig);
}

export const FirebaseContext =
  (createContext < firebase.analytics.Analytics) | (null > null);

const FirebaseTrackingProvider = (props: { children: ReactNode }) => {
  const router = useRouter();
  const [tracking, setTracking] =
    (useState < firebase.analytics.Analytics) | (null > null);

  useEffect(() => {
    setTracking(firebase.analytics());

    const handleRouteChange = (url: string) => {
      if (!tracking) {
        return;
      }
      tracking.logEvent("page_view", {
        page_location: url,
      });
    };

    router.events.on("routeChangeStart", handleRouteChange);

    return () => {
      router.events.off("routeChangeStart", handleRouteChange);
    };
  }, [tracking, router]);

  return (
    <FirebaseContext.Provider value={tracking}>
      {props.children}
    </FirebaseContext.Provider>
  );
};

export const useFirebase = () => useContext(FirebaseContext);

export default FirebaseTrackingProvider;
```

```javascript
// app.tsx
import type { AppProps } from "next/app";
import FirebaseContext from "../context/FirebaseContext";

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <FirebaseContext>
      <Component {...pageProps} />
    </FirebaseContext>
  );
}

export default MyApp;
```

이제 pages에 있는 모든 파일들, 즉 페이지가 바뀔 때 마다 firebase analytics의 이벤트가 생성이 되는 것은 물론이고 다른 구성요소 (components) 에서도 `useFirebase`를 사용해서
`firebase.analytics()`를 불러 올 수 있다. 그 것을 이용해서 다른 `logEvent`도 설정해 줄 수 있다!

---

## 🕊 이제 배포해야지

배포를 할때는, 앞서 말했듯이 env 파일을 직접적으로 올리면 안되기 때문에, Github Secrets를 이용해서 올려야한다.
Github Secrets를 사용하기 앞서 이번 블로그에 공부하는 겸 Github Actions를 한번 사용해보기로 했다.

```yaml
name: Deploy to Github pages
  ...
  # environment values
  - name: Create env file
    run : |
      touch .env &&
      echo NEXT_PUBLIC_API_KEY=${{ secrets.NEXT_PUBLIC_API_KEY }} >> .env &&
      echo NEXT_PUBLIC_AUTH_DOMAIN=${{ secrets.NEXT_PUBLIC_AUTH_DOMAIN }} >> .env &&
      echo NEXT_PUBLIC_PROJECT_ID=${{ secrets.NEXT_PUBLIC_PROJECT_ID }} >> .env &&
      echo NEXT_PUBLIC_STORAGE_BUCKET=${{ secrets.NEXT_PUBLIC_STORAGE_BUCKET }} >> .env &&
      echo NEXT_PUBLIC_MESSAGING_SENDER_ID=${{ secrets.NEXT_PUBLIC_MESSAGING_SENDER_ID }} >> .env &&
      echo NEXT_PUBLIC_APP_ID=${{ secrets.NEXT_PUBLIC_APP_ID }} >> .env &&
      echo NEXT_PUBLIC_MEASUREMENT_ID=${{ secrets.NEXT_PUBLIC_MEASUREMENT_ID }} >> .env &&
      echo WEBSITE_URL=${{ secrets.WEBSITE_URL }} >> .env &&
      cat .env
```

- .env 파일을 Github Actions에서 사용하는 방법은, 매번 .env 파일을 만들어 주는 방법이다.
- `${{secrets._______}}` 는 Github 페이지에서 프로젝트 > Settings > Secrets > Actions 에 New repository secret에 추가된 변수들과 같으므로, env 파일에 있는
  값들을 secret에 저장해주자.

아래는 전체 development.yml파일입니다

```yaml
name: Deploy to Github pages

on:
  push:
    branches: [master]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [14.x]

    steps:
      # checkout action
      - uses: actions/checkout@v3

      # Node version
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}

      # environment values
      - name: Create env file
        run: |
          touch .env &&
          echo NEXT_PUBLIC_API_KEY=${{ secrets.NEXT_PUBLIC_API_KEY }} >> .env &&
          echo NEXT_PUBLIC_AUTH_DOMAIN=${{ secrets.NEXT_PUBLIC_AUTH_DOMAIN }} >> .env &&
          echo NEXT_PUBLIC_PROJECT_ID=${{ secrets.NEXT_PUBLIC_PROJECT_ID }} >> .env &&
          echo NEXT_PUBLIC_STORAGE_BUCKET=${{ secrets.NEXT_PUBLIC_STORAGE_BUCKET }} >> .env &&
          echo NEXT_PUBLIC_MESSAGING_SENDER_ID=${{ secrets.NEXT_PUBLIC_MESSAGING_SENDER_ID }} >> .env &&
          echo NEXT_PUBLIC_APP_ID=${{ secrets.NEXT_PUBLIC_APP_ID }} >> .env &&
          echo NEXT_PUBLIC_MEASUREMENT_ID=${{ secrets.NEXT_PUBLIC_MEASUREMENT_ID }} >> .env &&
          echo WEBSITE_URL=${{ secrets.WEBSITE_URL }} >> .env &&
          cat .env

      - name: Installing my packages
        run: npm install

      - name: 🔨 Build my App
        run: npm run build

      - name: 📦 Export my App
        run: npm run export

      - run: touch ./out/.nojekyll
      - run: echo www._____.___ > out/CNAME # 만약 도메인을 구매했었다면 CNAME에 URL을 넣어주자

      - name: Deploy 🚀
        uses: JamesIves/github-pages-deploy-action@v4.2.5
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: gh-pages # The branch the action should deploy to.
          FOLDER: out # The folder the action should deploy.
          clean: true
```

---

## Conclusion

Next.js v12, Firebase v9 를 이용하여 Next.js를 Github Pages에 배포하는 방법을 알아봤습니다.
물론, vercel을 사용해서 배포하면 Next.js가 더 편해지겠지만 나처럼 깃헙에 때려 박아버리고 싶은 사람들이 있을 것 같아서
한 번 알아봤었다. 

이 블로그 업데이트를 계기로 Next.js 와 Firebase를 연동 시키는 방법도 유익했지만, 뭐니 뭐니해도 Github Actions를 
활용하여 배포혹은 build 할 수 있는 과정에서 많은 것을 배웠다 (본인은 이후에 sitemap을 바로 업데이트하는 스크립트도 여기에 넣어버렸다 😱)
Next.js를 이용해서 더욱 더 빠른 로딩시간도 확인했으니 앞으로는 React 뿐만 아니라 Next.js에 대해서도 많이 공부해야겠다!
